## 基本信息
目标URL：

## 描述  
静态网页

## 使用的包/工具/技术
|步骤|包/工具/技术|
|--|--|
|网页分析|Devtools|

## 问题与对应处理  
### 混淆解密  
这个混淆是可以解的  

## 分析  
既然是一个开源的，那就查看一下加密的源码吧  
Github: https://github.com/bprayudha/jquery.aaencode  

### 源码  
~~~javascript
(function($) {
    var aaencode = function(text) {
        var t;
        var b = [
            "(c^_^o)" ,
            "(ﾟΘﾟ)" ,
            "((o^_^o) - (ﾟΘﾟ))" ,
            "(o^_^o)" ,
            "(ﾟｰﾟ)" ,
            "((ﾟｰﾟ) + (ﾟΘﾟ))" ,
            "((o^_^o) +(o^_^o))" ,
            "((ﾟｰﾟ) + (o^_^o))" ,
            "((ﾟｰﾟ) + (ﾟｰﾟ))" ,
            "((ﾟｰﾟ) + (ﾟｰﾟ) + (ﾟΘﾟ))" ,
            "(ﾟДﾟ) .ﾟωﾟﾉ" ,
            "(ﾟДﾟ) .ﾟΘﾟﾉ" ,
            "(ﾟДﾟ) ['c']" ,
            "(ﾟДﾟ) .ﾟｰﾟﾉ" ,
            "(ﾟДﾟ) .ﾟДﾟﾉ" ,
            "(ﾟДﾟ) [ﾟΘﾟ]"
        ];
        var r = "ﾟωﾟﾉ= /｀ｍ´）ﾉ ~┻━┻   //*´∇｀*/ ['_']; o=(ﾟｰﾟ)  =_=3; c=(ﾟΘﾟ) =(ﾟｰﾟ)-(ﾟｰﾟ); "; 
        r += "(ﾟДﾟ) =(ﾟΘﾟ)= (o^_^o)/ (o^_^o);" +
            "(ﾟДﾟ)={ﾟΘﾟ: '_' ,ﾟωﾟﾉ : ((ﾟωﾟﾉ==3) +'_') [ﾟΘﾟ] " +
            ",ﾟｰﾟﾉ :(ﾟωﾟﾉ+ '_')[o^_^o -(ﾟΘﾟ)] "+
            ",ﾟДﾟﾉ:((ﾟｰﾟ==3) +'_')[ﾟｰﾟ] }; (ﾟДﾟ) [ﾟΘﾟ] =((ﾟωﾟﾉ==3) +'_') [c^_^o];" +
            "(ﾟДﾟ) ['c'] = ((ﾟДﾟ)+'_') [ (ﾟｰﾟ)+(ﾟｰﾟ)-(ﾟΘﾟ) ];"+
            "(ﾟДﾟ) ['o'] = ((ﾟДﾟ)+'_') [ﾟΘﾟ];"+
            "(ﾟoﾟ)=(ﾟДﾟ) ['c']+(ﾟДﾟ) ['o']+(ﾟωﾟﾉ +'_')[ﾟΘﾟ]+ ((ﾟωﾟﾉ==3) +'_') [ﾟｰﾟ] + " +
            "((ﾟДﾟ) +'_') [(ﾟｰﾟ)+(ﾟｰﾟ)]+ ((ﾟｰﾟ==3) +'_') [ﾟΘﾟ]+" +
            "((ﾟｰﾟ==3) +'_') [(ﾟｰﾟ) - (ﾟΘﾟ)]+(ﾟДﾟ) ['c']+" +
            "((ﾟДﾟ)+'_') [(ﾟｰﾟ)+(ﾟｰﾟ)]+ (ﾟДﾟ) ['o']+" +
            "((ﾟｰﾟ==3) +'_') [ﾟΘﾟ];(ﾟДﾟ) ['_'] =(o^_^o) [ﾟoﾟ] [ﾟoﾟ];" +
            "(ﾟεﾟ)=((ﾟｰﾟ==3) +'_') [ﾟΘﾟ]+ (ﾟДﾟ) .ﾟДﾟﾉ+"+
            "((ﾟДﾟ)+'_') [(ﾟｰﾟ) + (ﾟｰﾟ)]+((ﾟｰﾟ==3) +'_') [o^_^o -ﾟΘﾟ]+" +
            "((ﾟｰﾟ==3) +'_') [ﾟΘﾟ]+ (ﾟωﾟﾉ +'_') [ﾟΘﾟ]; " +
            "(ﾟｰﾟ)+=(ﾟΘﾟ); (ﾟДﾟ)[ﾟεﾟ]='\\\\'; " +
            "(ﾟДﾟ).ﾟΘﾟﾉ=(ﾟДﾟ+ ﾟｰﾟ)[o^_^o -(ﾟΘﾟ)];" + 
            "(oﾟｰﾟo)=(ﾟωﾟﾉ +'_')[c^_^o];" +
            "(ﾟДﾟ) [ﾟoﾟ]='\\\"';" + 
            "(ﾟДﾟ) ['_'] ( (ﾟДﾟ) ['_'] (ﾟεﾟ+" +
            "(ﾟДﾟ)[ﾟoﾟ]+ ";

        for( var i = 0; i < text.length; i++ ) {
            n = text.charCodeAt( i );
            t = "(ﾟДﾟ)[ﾟεﾟ]+";
            if( n <= 127 ) {
                t += n.toString( 8 ).replace( /[0-7]/g, function(c) {
                  return b[ c ] + "+ ";
                });
            }
            else {
                var m = /[0-9a-f]{4}$/.exec( "000" + n.toString(16 ) )[0];
                t += "(oﾟｰﾟo)+ " + m.replace( /[0-9a-f]/gi, function(c) {
                  return b[ parseInt( c,16 ) ] + "+ ";
                });
            }
            r += t;

        }
        
        r += "(ﾟДﾟ)[ﾟoﾟ]) (ﾟΘﾟ)) ('_');";
        
        return r;
    }

    $.fn.aaencode = function() {
        return aaencode(this.val());
    }
})(jQuery);
~~~
逐一调试观察逻辑并记录  
（为了调试方便改写了一些格式，但内容没改）  
~~~javascript
function _aaencode(text) {
    var t;
    // 定义一些表情字符用作替代目标, 里面的每一个表情都对应着一个真正的值
    // 在那些变量被赋值后(如(c^_^o)的c和o)，整个标签符号的值才会真正显现出来
    // 0-9 a-f
    var b = [
        "(c^_^o)",
        "(ﾟΘﾟ)",
        "((o^_^o) - (ﾟΘﾟ))",
        "(o^_^o)",
        "(ﾟｰﾟ)",
        "((ﾟｰﾟ) + (ﾟΘﾟ))",
        "((o^_^o) +(o^_^o))",
        "((ﾟｰﾟ) + (o^_^o))",
        "((ﾟｰﾟ) + (ﾟｰﾟ))",
        "((ﾟｰﾟ) + (ﾟｰﾟ) + (ﾟΘﾟ))",
        "(ﾟДﾟ) .ﾟωﾟﾉ",
        "(ﾟДﾟ) .ﾟΘﾟﾉ",
        "(ﾟДﾟ) ['c']",
        "(ﾟДﾟ) .ﾟｰﾟﾉ",
        "(ﾟДﾟ) .ﾟДﾟﾉ",
        "(ﾟДﾟ) [ﾟΘﾟ]"
    ];
    // r 实际上是最终字符串
    // 定义了一些变量
    var r =
        // "ﾟωﾟﾉ = /｀ｍ´）ﾉ ~┻━┻   //*´∇｀*/ ['_']
        "ﾟωﾟﾉ= /｀ｍ´）ﾉ ~┻━┻   //*´∇｀*/ ['_'];" +
        // o = 3
        // _ = 3
        " o=(ﾟｰﾟ)  =_=3;" +
        // c = 0
        // (ﾟΘﾟ) = 0
        " c=(ﾟΘﾟ) =(ﾟｰﾟ)-(ﾟｰﾟ); ";
    r +=
        // (ﾟДﾟ) = (ﾟΘﾟ) = 1
        "(ﾟДﾟ) =(ﾟΘﾟ)= (o^_^o)/ (o^_^o);" +
        // (ﾟДﾟ) = {ﾟΘﾟ: "_", ﾟωﾟﾉ: "a", ﾟｰﾟﾉ: "d", ﾟДﾟﾉ: "e"}
        "(ﾟДﾟ)={ﾟΘﾟ: '_' ,ﾟωﾟﾉ : ((ﾟωﾟﾉ==3) +'_') [ﾟΘﾟ] ,ﾟｰﾟﾉ :(ﾟωﾟﾉ+ '_')[o^_^o -(ﾟΘﾟ)] ,ﾟДﾟﾉ:((ﾟｰﾟ==3) +'_')[ﾟｰﾟ] }; " +
        // (ﾟДﾟ) [ﾟΘﾟ] = 'f'
        "(ﾟДﾟ) [ﾟΘﾟ] =((ﾟωﾟﾉ==3) +'_') [c^_^o];" +
        // (ﾟДﾟ) ['c'] = 'c'
        "(ﾟДﾟ) ['c'] = ((ﾟДﾟ)+'_') [ (ﾟｰﾟ)+(ﾟｰﾟ)-(ﾟΘﾟ) ];" +
        // (ﾟДﾟ) ['o'] = 'o'
        "(ﾟДﾟ) ['o'] = ((ﾟДﾟ)+'_') [ﾟΘﾟ];" +
        // constructor
        "(ﾟoﾟ)=(ﾟДﾟ) ['c']+(ﾟДﾟ) ['o']+(ﾟωﾟﾉ +'_')[ﾟΘﾟ]+ ((ﾟωﾟﾉ==3) +'_') [ﾟｰﾟ] + ((ﾟДﾟ) +'_') [(ﾟｰﾟ)+(ﾟｰﾟ)]+ ((ﾟｰﾟ==3) +'_') [ﾟΘﾟ]+((ﾟｰﾟ==3) +'_') [(ﾟｰﾟ) - (ﾟΘﾟ)]+(ﾟДﾟ) ['c']+((ﾟДﾟ)+'_') [(ﾟｰﾟ)+(ﾟｰﾟ)]+ (ﾟДﾟ) ['o']+((ﾟｰﾟ==3) +'_') [ﾟΘﾟ];" +
        // (ﾟДﾟ) ['_'] =  3['constructor']['constructor'] 等价于 ƒ Function() { [native code] }
        "(ﾟДﾟ) ['_'] =(o^_^o) [ﾟoﾟ] [ﾟoﾟ];" +
        // (ﾟεﾟ) = 'return'
        "(ﾟεﾟ)=((ﾟｰﾟ==3) +'_') [ﾟΘﾟ]+ (ﾟДﾟ) .ﾟДﾟﾉ+((ﾟДﾟ)+'_') [(ﾟｰﾟ) + (ﾟｰﾟ)]+((ﾟｰﾟ==3) +'_') [o^_^o -ﾟΘﾟ]+((ﾟｰﾟ==3) +'_') [ﾟΘﾟ]+ (ﾟωﾟﾉ +'_') [ﾟΘﾟ]; " +
        // (ﾟｰﾟ) = 3
        "(ﾟｰﾟ)+=(ﾟΘﾟ);",
        // (ﾟДﾟ)[ﾟεﾟ] = "\\"
        "(ﾟДﾟ)[ﾟεﾟ]='\\\\'; " +
        // (ﾟДﾟ).ﾟΘﾟﾉ = "b"
        "(ﾟДﾟ).ﾟΘﾟﾉ=(ﾟДﾟ+ ﾟｰﾟ)[o^_^o -(ﾟΘﾟ)];" +
        // (oﾟｰﾟo) = 'u'
        "(oﾟｰﾟo)=(ﾟωﾟﾉ +'_')[c^_^o];" +
        // (ﾟДﾟ) [ﾟoﾟ] = "\\\""
        "(ﾟДﾟ) [ﾟoﾟ]='\\\"';" +
        // function (function (return object 中间导入的字符串 ))
        "(ﾟДﾟ) ['_'] ( (ﾟДﾟ) ['_'] (ﾟεﾟ+(ﾟДﾟ)[ﾟoﾟ]+ (ﾟДﾟ)[ﾟoﾟ]) (ﾟΘﾟ)) ('_');";

    // 遍历传入字符串的所有字符
    for (var i = 0; i < text.length; i++) {
        n = text.charCodeAt(i);
        // charCodeAt() 方法可返回指定位置的字符的 Unicode 编码数
        // 每一个字符的标记记录 默认在前面就有一个表情
        t = "(ﾟДﾟ)[ﾟεﾟ]+";
        if (n <= 127) {
            // unicode 只处理 C0控制与基本的Latin（拉丁字母），这其实已经包含了绝大部分的js源码符号
            // 将 十进制数字符串 转为 为8进制数字符串
            n = n.toString(8);
            // 对八进制数字符串 里的每一个数字(0-7) 用 预先定义好的表情符合进行取代
            t += n.replace(/[0-7]/g, function (c) {
                return b[c] + "+ ";
                // 取代完以后，在最后添加一个 '+ '用于最后eval函数拼接而不出问题
            });
        } else {
            // 对于非C0控制与基本的Latin（拉丁字母）。即 非js代码部分，诸如中文之类的
            // 用 "000"+原字符数字转16进制
            n = "000" + n.toString(16);
            // 用正则表达式/[0-9a-f]{4}$/ 在 十六进数字字符 中寻找匹配项 并返回最短匹配
            var m = /[0-9a-f]{4}$/.exec(n)[0];
            // 将这个 十六进数字字符 转为对应的10进制数字（因为记录表情的是一个数组，如果传入a-f字符来获取表情的话会报错，所以转10进制数），再转为表情，在最后添加一个 '+ '
            m = m.replace(/[0-9a-f]/gi, function (c) {
                return b[parseInt(c, 16)] + "+ ";
            });
            // 字符结果添加前缀 u以作Unicode字符标记
            t += "(oﾟｰﾟo)+ " + m;
        }
        // 单个字符汇总到答案
        r += t;

    }

    // 添加结尾字符
    r += "(ﾟДﾟ)[ﾟoﾟ]) (ﾟΘﾟ)) ('_');";

    // 返回整个字符串
    return r;
}
~~~
在详细分析以后，过程是比较得明朗的  

## 过程
1. 定义一个 表情符号数组
为了增加迷惑性，设定一个表情符号数组，用作未来取代`javascript`代码字符    

1. 定义外围函数包围原本的代码  
最外面包裹着一层 执行解释函数  
通过各种奇怪的符号构造出 `()["constructor"]["constructor"](执行代码)()`  
`()["constructor"]["constructor"](执行代码)()`等价于`Function (执行代码)()`，能执行代码  

1. 原本的js代码通过`unicode编码`后映射到了一个数上，作者将这个数做了区分处理  
   * 这个数在0-127之间，说明是数字字母等javascript代码原本需要用到的字符 [C0 控制与基本的 Latin（拉丁字母）](https://www.runoob.com/charsets/ref-utf-basic-latin.html)    
     这种字符作者将数转为8进制后，将每一位的数转为表情字符
   * 这个数超出127，说明这个字符并非常规的字母数字等，而是一些较少使用的字符，如中文之类的  
    这种字符作者将数转为16进制后，将每一位的数转为表情字符，最后在前面添加一个"(oﾟｰﾟo)"（实际上是字符 u）用作标识Unicode字符  
* 为什么可以转为表情  
    实际上，在一开始的变量声明完毕以后，表情字符本身的值就等于序号（16进制，超出的会对应a-f）  
    这是作者设定好的，混淆是让你看不懂，并不会破坏逻辑本身  
    你可以尝试着去获取那些值  
        


## 解法  
1. 删掉最后的`('_');";`,若是不行，可以在后面加`toString()`来把函数转为字符串输出  
由于代码是`()["constructor"]["constructor"](执行代码)()`这种形式的  
如果你把最后的括号删掉，那么源代码函数就会暴露出来，直接得到源码了  

1. 进入虚拟空间VM即可看到源码  
在执行混淆代码之前，打上断点，步进到混淆代码内部，分析堆栈，进入虚拟空间，就能看到源码了  
如果内部代码执行报错，那么也可以通过报错的定位进入虚拟空间  

<p style="text-align:right">Recluse<br>2020年8月13日14:53:10 </p>